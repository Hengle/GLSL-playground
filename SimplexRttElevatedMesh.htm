<html lang="en">
    <head>
        <title>WebGL/GLSL - Simplex render to texture mesh</title>
        <meta charset="utf-8">
    </head>

    <body>
        <div id="container"></div>
    </body>

    <script src="js/Three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/Prototype.js"></script>
    <script src="js/NoiseRTT.js"></script>

    <script type="x-shader/x-vertex" id="noiseVertexShader">
        // Vertex Shader code

        varying vec2 v_texCoord2D;

        void main() {
            gl_Position = vec4(position.xy, 0.0, 1.0);
            v_texCoord2D = position.xy;
        }
    </script>

    <script type="x-shader/x-fragment" id="noiseFragmentShader">
        // Fragment Shader code

        uniform float seed;
        uniform vec2 uvScale;
        uniform vec2 offset;

        varying vec2 v_texCoord2D;

        //
        // Description : Array and textureless GLSL 3D simplex
        //               noise function.
        //      Author : Ian McEwan, Ashima Arts.
        //  Maintainer : ijm
        //     Lastmod : 20110822 (ijm)
        //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
        //               Distributed under the MIT License. See LICENSE file.
        //               https://github.com/ashima/webgl-noise
        //

        vec3 mod289(vec3 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
        }

        vec4 mod289(vec4 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
        }

        vec4 permute(vec4 x) {
            return mod289(((x * 34.0) + 1.0) * x);
        }

        vec4 taylorInvSqrt(vec4 r) {
            return 1.79284291400159 - 0.85373472095314 * r;
        }

        float snoise(vec3 v) {
            const vec2 C = vec2(1.0 /6.0, 1.0 / 3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

            // First corner
            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 x0 =   v - i + dot(i, C.xxx);

            // Other corners
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);

            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

            // Permutations
            i = mod289(i);
            vec4 p = permute(permute(permute(
                     i.z + vec4(0.0, i1.z, i2.z, 1.0))
                   + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                   + i.x + vec4(0.0, i1.x, i2.x, 1.0));

            // Gradients: 7x7 points over a square, mapped onto an octahedron.
            // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
            float n_ = 0.142857142857; // 1.0/7.0
            vec3  ns = n_ * D.wyz - D.xzx;

            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);

            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);

            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));

            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);

            //Normalise gradients
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;

            // Mix final noise value
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1),
                                        dot(p2,x2), dot(p3,x3)));
        }

        // fractional brownian motion, also called turbulence
        float fBm(vec3 v, float lacunarity, float gain) {
            float sum = 0.0;
            float amp = 1.0;
            vec3 V = v;

            // 6 octaves of noise
            for(int i = 0; i < 6; i++) {
                sum += amp * snoise(V);
                amp *= gain;
                V *= lacunarity;
            }
            return sum;
        }

        void main() {
            vec2 uv = (v_texCoord2D + offset) * uvScale;
            float h = fBm(vec3(uv, seed), 2.0, 0.5);
            gl_FragColor = vec4(vec3(0.5 + 0.4 * h), 1.0);
        }
    </script>

    <script type="x-shader/x-vertex" id="displayVertexShader">
        // Vertex Shader code

        uniform sampler2D heightmapTexture;
        varying float height;

        void main() {
            // lookup for height on the texture map, taking red channel as height.
            height = texture2D(heightmapTexture, uv).x;
            // apply a factor to get displacement
            float displacement = height * 1500.0;
            // displace the vertex
            vec3 newPosition = vec3(position.x, position.y, position.z + displacement);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="displayFragmentShader">
        // Fragment Shader code

        varying float height;

        void main() {
            gl_FragColor = vec4(0.0, 0.0, height, 1.0);
        }
    </script>

    <script type="text/javascript" id="mainCode">
        var container,
            renderer,
            scene,
            material,
            mesh,
            camera,
            fov = 60,
            noiseRTT,
            clock = new THREE.Clock();

        window.addEventListener('load', function() {

            // grab the container from the DOM
            container = document.getElementById("container");

            // create the renderer and attach it to the DOM
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            // set a black background color
            renderer.setClearColor(0);

            container.appendChild(renderer.domElement);

            // create a scene
            scene = new THREE.Scene();

            // create axis helpers and add them to the scene
            var axes = new THREE.AxisHelper(200);
            scene.add(axes);

            // create a camera the size of the browser window
            camera = new THREE.PerspectiveCamera(
                fov,
                window.innerWidth / window.innerHeight,
                1,
                20000);
            camera.position.y = -4000;
            camera.position.z = 3500;

            // controls
            controls = new THREE.OrbitControls(camera);
            controls.center.set(0.0, 100.0, 0.0);
            controls.userPanSpeed = 100;

            // add the camera to the scene
            scene.add(camera);

            // initialize noiseRTT
            var sizeX = 256;
            var sizeY = 256;
            var noiseScale = 2.0;
            var seed = 12345;
            noiseRTT = new NoiseRTT(sizeX, sizeY, noiseScale, seed);

            // create a shader material
            material = new THREE.ShaderMaterial({
                wireframe: true,
                uniforms: {
                    heightmapTexture: { type: "t", value: noiseRTT.getTexture() },
                },
                vertexShader: document.getElementById('displayVertexShader').textContent,
                fragmentShader: document.getElementById('displayFragmentShader').textContent
            });

            // create a plane mesh and assign the material, then add the mesh to the scene
            mesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(6000, 6000, 256, 256),
                material
            );
            scene.add(mesh);

            render();
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function render() {
            controls.update(clock.getDelta());

            // render noise to texture
            renderer.setSize(256, 256);
            noiseRTT.render(renderer, 0, 0);

            // render scene
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.render(scene, camera);

            requestAnimationFrame(render);
        }
    </script>

</html>
