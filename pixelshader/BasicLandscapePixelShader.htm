<html lang="en">
    <head>
        <title>WebGL/GLSL - Basic Landscape Pixel Shader</title>
        <meta charset="utf-8">
        <link rel="stylesheet" type="text/css" href="../css/styles.css">
    </head>

    <body>
        <div id="container"></div>
    </body>

    <script src="../js/Three.min.js"></script>
    <script src="../js/Detector.js"></script>

    <script type="x-shader/x-vertex" id="vertexShader">
        // Vertex Shader code

        void main() {
            gl_Position = vec4(position.xy, 1.0, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        // Fragment Shader code

        uniform vec2 uResolution;
        uniform float uGlobalTime;
        uniform vec4 uMouse;
        uniform sampler2D uTexture0;
        uniform sampler2D uTexture1;

        vec3 sunColor = vec3(1.8, 1.0, 0.6);
        vec3 skyColor = vec3(0.4, 0.6, 0.75);
        vec3 sunLightColor = vec3(1.7, 1.25, 0.9);
        vec3 skyLightColor = vec3(0.15, 0.2, 0.3);
        vec3 indLightColor = vec3(0.4, 0.3, 0.2);
        vec3 cloudsColor = vec3(1.0, 1.0, 1.0);
        vec3 horizonColor = vec3(0.7, 0.75, 0.8);
        vec3 fogColorB = vec3(0.7, 0.8, 0.9);
        vec3 fogColorR = vec3(0.8, 0.7, 0.6);

        vec3 sunDirection = normalize(vec3(0.6, 0.4, 0.9));

        float cloudsHeight = 800.0;
        float cloudsDensity = 0.3;
        float cloudsCover = 0.2;

        float maxmipmap = 100.0;

        float noise2d(in vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            vec2 uv = i + f + vec2(128.0, 128.0);
            float h = texture2D(uTexture0, uv / 256.0, 0.0 - maxmipmap).r;
            return h * 2.0 - 1.0;
        }

        float fBm(in vec2 p) {
            float sum = 0.0;
            float amp = 1.0;
            for(int i = 0; i < 4; i++) {
                sum += amp * noise2d(p);
                amp *= 0.5;
                p *= 2.0;
            }
            return sum;
        }

        float fBmC(in vec2 p) {
            float sum = 0.0;
            float amp = 1.0;
            for(int i = 0; i < 5; i++) {
                sum += amp * noise2d(p);
                amp *= 0.5;
                p *= 2.0;
            }
            return sum;
        }

        float intersect(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {
            // terrain marching as explained by Inigo Quilez in his articles:
            // http://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm
            float t = tmin;
            for (int i = 0; i < 300; i++) {
                vec3 p = ro + rd * t;
                float h = p.y - fBm(p.xz);
                if (h < (0.001 * t) || t > tmax)
                    break;
                t += 0.2 * h;
            }
            return t;
        }

        vec3 getTerrainNormal(in vec3 p, float t) {
            // computes terrain normal with central differences: http://en.wikipedia.org/wiki/Finite_difference
            // the method is explained by Inigo Quilez in his article on terrain marching.
            float eps = 0.025;
            return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),
                                  2.0 * eps,
                                  fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));
        }

        float rayMarchShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {
            // penumbra shadows as described by IQ in article "free penumbra shadows
            // for raymarching distance fields":
            // http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm
            float sh = 1.0;
            float t = tmin;
            for(int i = 0; i < 50; i++) {
                vec3 p = ro + rd * t;
                float h = p.y - fBm(p.xz);
                sh = min(sh, 8.0 * h / t);
                t += 0.5 * h;
                if (h < (0.001 * t) || t > tmax)
                    break;
            }
            return sh;
        }

        void main() {
            vec2 p = gl_FragCoord.xy / uResolution.xy * 2.0 - 1.0;
            vec3 norm = normalize(vec3(p.xy, 1.0));

            vec3 ro = vec3(1.0 + cos(uGlobalTime * 0.1) * 1.0, 2.0 + sin(uGlobalTime * 0.1) * 0.5 - 0.15, 1.0 + uGlobalTime * 0.5);
            vec3 rd = norm;

            float sunDot = clamp(dot(sunDirection, norm), 0.0, 1.0);

            // terrain marching
            float tmin = 0.1;
            float tmax = 50.0;
            float t = intersect(ro, rd, tmin, tmax);
            vec3 color;
            if (t < tmax) {
                // get position where the ray has hit
                vec3 tpos = ro + rd * t;
                // get terrain normal at that position
                vec3 tnorm = getTerrainNormal(tpos, t);

                // 3 lights rig as explained by Inigo Quilez in outdoor lighting article:
                // http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm
                // light from sun direction
                float sun = clamp(dot(sunDirection, tnorm), 0.0, 1.0);
                // light from skydome
                float sky = clamp(0.5 + 0.5 * tnorm.y, 0.0, 1.0);
                // indirect light reflected back in opposite direction of the sun
                float ind = clamp(dot(vec3(-sunDirection.x, 0.0, -sunDirection.z), tnorm), 0.0, 1.0);
                // raymarching penumbra shadows
                float shadow = clamp(rayMarchShadow(tpos, sunDirection, 0.5, 50.0), 0.0, 1.0);
                // compute light color
                vec3 lightColor = 1.2 * sun * sunLightColor;    // sunlight
                lightColor *= pow(vec3(shadow), sunLightColor); // multiply sunlight by penumbra shadows
                lightColor += 0.7 * sky * skyLightColor;        // add skylight
                lightColor += 0.3 * ind * indLightColor;        // add backlight

                // rock
                color = 0.2 * texture2D(uTexture1, tpos.xz, 0.0 - maxmipmap).rgb;
                color *= 1.25 * lightColor;

                // fog: mixes a blue fog, and a red fog with sun amount
                // this is described by IQ in his "Better Fog" article:
                // http://www.iquilezles.org/www/articles/fog/fog.htm
                vec3 fogColor = mix(fogColorB, fogColorR, pow(sunDot, 4.0));
                color = mix(color, 0.8 * fogColor, 1.0 - exp(-0.0005 * t * t));

            } else {
                // sky and sun
                float sky = clamp(0.6 * (1.0 - 0.8 * norm.y), 0.0, 1.0);
                float diffuse = clamp(0.4 * sunDot, 0.0, 1.0);
                color = sky * skyColor + pow(sunDot, 800.0) * sunColor + diffuse * skyLightColor;

                // clouds
                t = (cloudsHeight - ro.y) / rd.y;
                if (t > 0.0) {
                    vec3 pos = ro + rd * t;
                    pos.z += uGlobalTime * 10.0;
                    float clouds = fBmC(0.0025 * pos.xz) * cloudsDensity + cloudsCover;
                    color = mix(color, mix(cloudsColor * 1.1, sunColor + diffuse * sunLightColor, 0.25), 0.8 * smoothstep(0.1, 0.9, clouds));
                }

                // horizon
                color = mix(color, horizonColor, pow(1.0 - rd.y, 4.0));
            }

            // gamma correction
            vec3 gamma = vec3(1.0 / 2.2);
            gl_FragColor = vec4(pow(color, gamma), 1.0);
        }
    </script>

    <script type="text/javascript" id="mainCode">
        var container,
            renderer,
            scene,
            mesh,
            camera,
            leftMouseButtonDown = false,
            clock = new THREE.Clock();

        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('load', function() {

            // grab the container from the DOM
            container = document.getElementById("container");

            // create a scene
            scene = new THREE.Scene();

            // create a camera the size of the browser window
            camera = new THREE.PerspectiveCamera(
                90,
                window.innerWidth / window.innerHeight,
                1,
                10000);
            camera.position.z = 200;

            // add the camera to the scene
            scene.add(camera);

            // load noise texture
            var tex0 = THREE.ImageUtils.loadTexture("textures/noise2d.png");
            tex0.wrapS = tex0.wrapT = THREE.RepeatWrapping;
            var tex1 = THREE.ImageUtils.loadTexture("textures/12347-v4.jpg");
            tex1.wrapS = tex1.wrapT = THREE.RepeatWrapping;

            // create a shader material
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uResolution: { type:"v2", value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uGlobalTime: { type:"f", value: 1.0 },
                    uMouse: { type:"v4", value: new THREE.Vector4(0, 0, 0, 0) },
                    uTexture0: { type:"t", value: tex0 },
                    uTexture1: { type:"t", value: tex1 },
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                depthTest: false
            });

            // create a plane mesh and assign the material, then add the mesh to the scene (fullscreen quad)
            mesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(2, 2),
                material
            );
            scene.add(mesh);

            // create the renderer and attach it to the DOM
            if (Detector.webgl)
                renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    antialias:true
                });
            else
                renderer = new THREE.CanvasRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);

            container.appendChild(renderer.domElement);

            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);

            render();
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms["uResolution"].value = new THREE.Vector2(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(e) {
            if (e.button === 0) {
                leftMouseButtonDown = true;
            }
            var vec4Mouse = material.uniforms["uMouse"].value;
            vec4Mouse.z = e.clientX;
            vec4Mouse.w = e.clientY;
        }

        function onMouseUp(e) {
            if (e.button === 0) {
                leftMouseButtonDown = false;
            } else {
                var vec4Mouse = material.uniforms["uMouse"].value;
                vec4Mouse.z = 0.0;
                vec4Mouse.w = 0.0;
            }
        }

        function onMouseMove(e) {
            if (leftMouseButtonDown === true) {
                var vec4Mouse = material.uniforms["uMouse"].value;
                vec4Mouse.x = e.clientX;
                vec4Mouse.y = e.clientY;
            }
        }

        function render() {
            material.uniforms["uGlobalTime"].value = clock.getElapsedTime();

            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }
    </script>

</html>
