<html lang="en">
    <head>
        <title>WebGL/GLSL - Pixel Shader</title>
        <meta charset="utf-8">
        <style>
            body {
                margin :0;
            }
            canvas {
                width: 100%;
                height: 100%;
                background: #000;
                display: block; /* fix necessary to remove space at bottom of canvas */
            }
            #container {
                background: #000;
                width: 100%;
                height: 100%;
            }
        </style>
    </head>

    <body>
        <div id="container"></div>
    </body>

    <script src="../js/Three.min.js"></script>
    <script src="../js/Detector.js"></script>

    <script type="x-shader/x-vertex" id="vertexShader">
        // Vertex Shader code

        void main() {
            gl_Position = vec4(position.xy, 1.0, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        // Fragment Shader code

        uniform vec2 iResolution;
        uniform float iGlobalTime;
        uniform vec4 iMouse;
        uniform vec4 iDate;

        void main() {
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            gl_FragColor = vec4(uv, 0.5 + 0.5 * sin(iGlobalTime), 1.0);
        }
    </script>

    <script type="text/javascript" id="mainCode">
        var container,
            renderer,
            scene,
            mesh,
            camera,
            leftMouseButtonDown = false,
            clock = new THREE.Clock();

        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('load', function() {

            // grab the container from the DOM
            container = document.getElementById("container");

            // create a scene
            scene = new THREE.Scene();

            // create a camera the size of the browser window
            camera = new THREE.PerspectiveCamera(
                90,
                window.innerWidth / window.innerHeight,
                1,
                10000);
            camera.position.z = 200;

            // add the camera to the scene
            scene.add(camera);

            // create a shader material
            material = new THREE.ShaderMaterial({
                uniforms: {
                    iResolution: { type:"v2", value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    iGlobalTime: { type:"f", value: 1.0 },
                    iMouse: { type:"v4", value: new THREE.Vector4(window.innerWidth / 2, window.innerHeight / 2, 0, 0) },
                    iDate: { type:"v4", value: new THREE.Vector4(0, 0, 0, 0) }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                depthTest: false
            });

            // create a plane mesh and assign the material, then add the mesh to the scene (fullscreen quad)
            mesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(2, 2),
                material
            );
            scene.add(mesh);

            // create the renderer and attach it to the DOM
            if (Detector.webgl)
                renderer = new THREE.WebGLRenderer();
            else
                renderer = new THREE.CanvasRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);

            container.appendChild(renderer.domElement);

            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);

            render();
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(e) {
            if (e.button === 0) {
                leftMouseButtonDown = true;
            }
            var vec4Mouse = material.uniforms["iMouse"].value;
            vec4Mouse.z = e.clientX;
            vec4Mouse.w = e.clientY;
        }

        function onMouseUp(e) {
            if (e.button === 0) {
                leftMouseButtonDown = false;
            }
            var vec4Mouse = material.uniforms["iMouse"].value;
            vec4Mouse.z = 0.0;
            vec4Mouse.w = 0.0;
        }

        function onMouseMove(e) {
            if (leftMouseButtonDown === true) {
                var vec4Mouse = material.uniforms["iMouse"].value;
                vec4Mouse.x = e.clientX;
                vec4Mouse.y = e.clientY;
            }
        }

        function render() {
            material.uniforms["iGlobalTime"].value = clock.getElapsedTime();
            var d = new Date();
            var vec4Date = material.uniforms["iDate"].value;
            vec4Date.x = d.getFullYear();
            vec4Date.y = d.getMonth();
            vec4Date.z = d.getDay();
            vec4Date.w = d.getSeconds();

            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }
    </script>

</html>
